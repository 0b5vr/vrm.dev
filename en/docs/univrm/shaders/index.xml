<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>VRM â€“ Material</title><link>https://vrm.dev/en/docs/univrm/shaders/</link><description>Recent content in Material on VRM</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 16 Apr 2018 16:30:00 +0900</lastBuildDate><atom:link href="https://vrm.dev/en/docs/univrm/shaders/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: MToon</title><link>https://vrm.dev/en/docs/univrm/shaders/shader_mtoon/</link><pubDate>Mon, 16 Apr 2018 16:30:00 +0900</pubDate><guid>https://vrm.dev/en/docs/univrm/shaders/shader_mtoon/</guid><description>
&lt;p>&lt;a href="https://www.slideshare.net/VirtualCast/vrm-mtoon">How to use MToon&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=EpCv23bnkAk">Introduction video&lt;/a> of MToon and other VRMShaders.&lt;/p>
&lt;h1 id="about-mtoon">About MToon&lt;/h1>
&lt;p>MToon aims for making Japanese anime expressions. It is achieved by mixing &lt;code>Lit Color&lt;/code> and &lt;code>Shade Color&lt;/code> based on Lighting parameters and light source environment.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;img src="https://vrm.dev/images/vrm/mtoon_about.png" alt="alicia MToon" />
&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Apply MToon to the 3D model&lt;code>Alicia&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="quick-setup">Quick Setup&lt;/h1>
&lt;h2 id="basic-walk-through">Basic Walk Through&lt;/h2>
&lt;ul>
&lt;li>Select the target material and change the shader to &lt;code>VRM/MToon&lt;/code>&lt;/li>
&lt;li>Click the shader panel and set the same texture in &lt;code>Color-&amp;gt;Lit Color, Alpha&lt;/code> and &lt;code>Color-&amp;gt;Shade Color&lt;/code>&lt;/li>
&lt;li>Set white color in &lt;code>Color-&amp;gt;Lit Color, Alpha&lt;/code> and set the preference shade color in &lt;code>Color-&amp;gt;Shade Color&lt;/code>&lt;/li>
&lt;li>Set the preference value in &lt;code>Shading-&amp;gt;Toony&lt;/code>. Make the lit color and shade color sharp:&lt;code>1&lt;/code>&lt;/li>
&lt;li>Set the texture in &lt;code>Rim-&amp;gt;Additive&lt;/code> (equivalent to &lt;code>sphere map&lt;/code> or &lt;code>Matcap&lt;/code>)&lt;/li>
&lt;li>If outline is necessary, select &lt;code>WorldCoordinates&lt;/code> in &lt;code>Outline-&amp;gt;Width-&amp;gt;Mode&lt;/code>. Select &lt;code>None&lt;/code> if outline is not needed&lt;/li>
&lt;li>Set the value with good appearance in &lt;code>Outline-&amp;gt;Width-&amp;gt;Width&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="general-material">General Material&lt;/h2>
&lt;ul>
&lt;li>Choose &lt;code>Shading Shift&lt;/code> and set &lt;code>0&lt;/code>&lt;/li>
&lt;li>Choose &lt;code>Shading Toony-&amp;gt;Shadow Receive Multiplier&lt;/code> and set &lt;code>1&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="set-materials-not-being-shadowed-too-much-such-as-the-characters-face">Set materials not being shadowed too much such as the character&amp;rsquo;s face&lt;/h2>
&lt;ul>
&lt;li>Choose &lt;code>Shading Shift&lt;/code> and set a negative value&lt;/li>
&lt;li>Choose &lt;code>Shading Toony-&amp;gt;Shadow Receive Multiplier&lt;/code> and set &lt;code>0&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="items-setup">Items Setup&lt;/h1>
&lt;h2 id="preliminary">Preliminary&lt;/h2>
&lt;p>Select the target material and change the shader to VRM/MToon.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;img src="https://vrm.dev/images/vrm/set_mtoon.png" alt="select MToon" />
&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Change the material shader to VRM/MToon&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="rendering">Rendering&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;img src="https://vrm.dev/images/vrm/mtoon_inspector_rendering.png" alt="MToon Rendering" />
&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>The items included in the Rendering Inspector&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Set the rendering type and cull mode in &lt;code>Rendering&lt;/code>.&lt;/p>
&lt;h3 id="rendering-type">Rendering Type&lt;/h3>
&lt;p>Set whether the material is opaque or semi-transparent.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Opaque&lt;/p>
&lt;ul>
&lt;li>For rendering performance, it is recommended to set &lt;code>Opaque&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Cutout&lt;/p>
&lt;ul>
&lt;li>Although it is opaque, it refers to the alpha value in &lt;code>Color-&amp;gt;Lit Color, Alpha&lt;/code>. Therefore, it skips rendering for places having smaller value than &lt;code>Color-&amp;gt;Alpha-&amp;gt;Cutoff&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Transparent&lt;/p>
&lt;ul>
&lt;li>The opacity based on the alpha value in &lt;code>Color-&amp;gt;Lit Color, Alpha&lt;/code>.&lt;/li>
&lt;li>The downside is that outline rendering cannot be performed correctly.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="cull-mode">Cull Mode&lt;/h3>
&lt;p>Set which side of the polygon to be rendered.&lt;/p>
&lt;ul>
&lt;li>Back
&lt;ul>
&lt;li>Render the front side. Generally selecting &amp;ldquo;Back&amp;rdquo; is recommended.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Front
&lt;ul>
&lt;li>Render the back side.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>None
&lt;ul>
&lt;li>Render the both sides.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="alpha">Alpha&lt;/h3>
&lt;p>Required if choosing &lt;code>Rendering Type-&amp;gt;Cutout&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Cutoff (&lt;code>Color-&amp;gt;Alpha&lt;/code>)
&lt;ul>
&lt;li>Set the threshold value for not rendering.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="color">Color&lt;/h2>
&lt;p>Set the rendering color.
The texture and color are multiplied.
Set the color hit by the light ray in &lt;code>Lit Color, Alpha&lt;/code> and set the color not hit by the light ray in &lt;code>Shade Color&lt;/code>.&lt;br>
Also, set the the alpha value in &lt;code>Lit Color, Alpha&lt;/code> for opacity information.&lt;/p>
&lt;h2 id="lighting">Lighting&lt;/h2>
&lt;h3 id="shading-shift">Shading Shift&lt;/h3>
&lt;p>Adjust the threshold value of the lit color and shade color for how the light ray hits the object.
When the value is &lt;code>0&lt;/code>, it is the normal lighting.
When the value is negative, it becomes the lighting with anime-like, wide range of lit color.
It is necessary to disable the self-shadow with setting the value to &lt;code>0&lt;/code> in &lt;code>Shadow Receive Multiplier&lt;/code> according to the displayed warning message.&lt;/p>
&lt;h3 id="shading-toony">Shading Toony&lt;/h3>
&lt;p>Set whether to smoothly change the lit color and shade color around the threshold value in &lt;code>Shade Shift&lt;/code>.
When the value is &lt;code>0&lt;/code>, it becomes realistically smooth like a general Lambert model.
When the value is &lt;code>1&lt;/code>, it becomes animation-style lighting. The lit color and shade color change rapidly around the threshold value.&lt;/p>
&lt;h3 id="shadow-receive-multiplier">Shadow Receive Multiplier&lt;/h3>
&lt;p>Set the influence of the self-shadow and shadow.
&lt;code>0&lt;/code>: Not affected.
&lt;code>1&lt;/code>: Affected.&lt;/p>
&lt;h3 id="lightcolor-attenuation">LightColor Attenuation&lt;/h3>
&lt;p>Set the influence of the light source color.
&lt;code>0&lt;/code>: Affected by the light source color.
&lt;code>1&lt;/code>: Not affected by the light source color. It only reflects the luminance of the light source color.&lt;/p>
&lt;h3 id="rim-additive">Rim Additive&lt;/h3>
&lt;p>Display additional light sources based on the relationship between the camera and the normal.
In general it is called sphere map or matcap.&lt;/p>
&lt;h3 id="emission">Emission&lt;/h3>
&lt;p>Set the constant color regardless of the light source environment.&lt;/p>
&lt;h3 id="normal-map">Normal Map&lt;/h3>
&lt;p>Set the normal map.
Set the strength value in the box on the right.&lt;/p>
&lt;h2 id="outline">Outline&lt;/h2>
&lt;p>Set the outline.&lt;/p>
&lt;h3 id="width-mode">Width Mode&lt;/h3>
&lt;ul>
&lt;li>None
&lt;ul>
&lt;li>The outline is not rendered&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>WorldCoordinates
&lt;ul>
&lt;li>Render the outline of the constant width for the world coordinate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ScreenCoordinates
&lt;ul>
&lt;li>Render the outline of the constant width for the screen coordinate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="width">Width&lt;/h3>
&lt;p>Set the width of the outline.
The unit of distance is meter when &lt;code>Width Mode-&amp;gt;WorldCoordinates&lt;/code> is chosen.&lt;/p>
&lt;h3 id="color-mode">Color Mode&lt;/h3>
&lt;ul>
&lt;li>FixedColor
&lt;ul>
&lt;li>Render with the fixed color&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MixedLighting
&lt;ul>
&lt;li>Multiply the influence of Lighting&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="color-1">Color&lt;/h3>
&lt;p>Set the outline color.&lt;/p>
&lt;h3 id="color-lighting-mix">Color Lighting Mix&lt;/h3>
&lt;p>Set the multiplier coefficient when &lt;code>Color Mode-&amp;gt;MixedLighting&lt;/code> is chosen.&lt;/p></description></item><item><title>Docs: UniUnlit</title><link>https://vrm.dev/en/docs/univrm/shaders/univrm_unlit/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://vrm.dev/en/docs/univrm/shaders/univrm_unlit/</guid><description>
&lt;h2 id="unigltfuniunlit-shader">&lt;code>UniGLTF/UniUnlit&lt;/code> shader&lt;/h2>
&lt;p>Unity has Unlit-type shaders:&lt;/p>
&lt;ul>
&lt;li>Unlit/Color&lt;/li>
&lt;li>Unlit/Texture&lt;/li>
&lt;li>Unlit/Transparent&lt;/li>
&lt;li>Unlit/Transparent Cutout&lt;/li>
&lt;/ul>
&lt;p>In GLTF, unlit is supported by &lt;code>KHR_materials_unlit&lt;/code> extension.
You can utilize &lt;code>doubleSided&lt;/code>, the product of &lt;code>Texture&lt;/code>, &lt;code>Color&lt;/code> and &lt;code>VertexColor&lt;/code> (if any), and &lt;code>color&lt;/code>'s alpha mode.
Given that there is no shader that can handle these features on Unity side, we introduce &lt;code>UniGLTF/UniUnlit&lt;/code>, which is fully compatible with all &lt;code>unlit&lt;/code> shaders in Unity.&lt;/p>
&lt;p>If Unlit-type shaders are re-imported after exporting, the shader will become &lt;code>UniGLTF/UniUnlit&lt;/code>.&lt;/p>
&lt;p>Below is the summary for Unlit-type shaders&amp;rsquo; export/import:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>export&lt;/th>
&lt;th>gltf&lt;/th>
&lt;th>import&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Unlit/Color&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Unlit/Texture&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Unlit/Transparent&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Unlit/Transparent Cutout&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VRM/UnlitTexture&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VRM/UnlitTransparent&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VRM/UnlitCutout&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;td>KHR_materials_unlit&lt;/td>
&lt;td>UniGLTF/UniUnlit&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Note that Only &lt;code>UniGLTF/UniUnlit&lt;/code> supports &lt;code>VertexColor&lt;/code>.
More specifically, &lt;code>VertexColor&lt;/code> can be enabled if the following two requirements are fulfilled:&lt;/p>
&lt;ul>
&lt;li>Mesh contains &lt;code>VertexColor&lt;/code> data&lt;/li>
&lt;li>Material is identified as &lt;code>Unlit&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>To disable &lt;code>VertexColor&lt;/code>, enabling &lt;code>RemoveVertexColor&lt;/code> in export dialog before exporting the VRM model. Otherwise, &lt;code>VertexColor&lt;/code> will be applied automatically to the mesh that has &lt;code>Unlit&lt;/code> material after importing.&lt;/p>
&lt;p>If &lt;code>KHR_materials_unlit&lt;/code> is declared, core PBR properties are ignored except baseColor. Color values, alpha coverage and double sided will still apply to unlit materials.&lt;/p>
&lt;h2 id="gltf">GLTF&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">UniUnlit&lt;/th>
&lt;th align="left">GLTF Unlit&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">Color Factor&lt;/td>
&lt;td align="left">/materials/pbrMetallicRoughness/baseColorFactor&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Color Texture&lt;/td>
&lt;td align="left">/materials/pbrMetallicRoughness/baseColorTexture&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Rendering Mode&lt;/td>
&lt;td align="left">/materials/alphaMode&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Cull Mode&lt;/td>
&lt;td align="left">/materials/doubleSided&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Standard</title><link>https://vrm.dev/en/docs/univrm/shaders/univrm_standard/</link><pubDate>Wed, 06 Jan 2021 18:03:33 +0900</pubDate><guid>https://vrm.dev/en/docs/univrm/shaders/univrm_standard/</guid><description>
&lt;h2 id="standard">Standard&lt;/h2>
&lt;p>The majority of &lt;a href="https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html">material parameters&lt;/a> in Unity&amp;rsquo;s standard shader are compatible with GLTF PBR materials:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">Unity Standard&lt;/th>
&lt;th align="left">GLTF PBR&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">Albedo Color&lt;/td>
&lt;td align="left">/materials/pbrMetallicRoughness/baseColorFactor&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Albedo Texture&lt;/td>
&lt;td align="left">/materials/pbrMetallicRoughness/baseColorTexture&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Metallic Level&lt;/td>
&lt;td align="left">/materials/pbrMetallicRoughness/metallicFactor&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Smoothness Level&lt;/td>
&lt;td align="left">1.0f - (/materials/pbrMetallicRoughness/roughnessFactor)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Metallic Texture&lt;/td>
&lt;td align="left">/materials/pbrMetallicRoughness/metallicRoughnessTexture&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Normal Map&lt;/td>
&lt;td align="left">/materials/normalTexture&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Bump scale&lt;/td>
&lt;td align="left">/materials/normalTexture/scale&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Height Map&lt;/td>
&lt;td align="left">N/A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Occlusion Texture&lt;/td>
&lt;td align="left">/materials/occlusionTexture&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Occlusion Strength&lt;/td>
&lt;td align="left">/materials/occlusionTexture/strength&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Emission Color&lt;/td>
&lt;td align="left">/materials/emissiveFactor&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Emission Texture&lt;/td>
&lt;td align="left">/materials/emissiveTexture&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Detail Mask&lt;/td>
&lt;td align="left">N/A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Secondary Maps&lt;/td>
&lt;td align="left">N/A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Rendering Mode&lt;/td>
&lt;td align="left">/materials/alphaMode&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>For UniVRM&amp;rsquo;s material import, the roughnessFactor value is baked into the Metallic Texture. For material export, the smoothness value is baked into the Metallic Texture (&lt;a href="https://github.com/vrm-c/UniVRM/pull/222">discussion&lt;/a>).&lt;/p>
&lt;p>Since part of the texture specifications between Unity and GLTF are not interchangeable, we use UniVRM&amp;rsquo;s &lt;code>export/import&lt;/code> to convert textures between Unity and GLTF.&lt;/p>
&lt;h2 id="improvement-standardshaders-texture-conversion">Improvement: StandardShader&amp;rsquo;s Texture Conversion&lt;/h2>
&lt;p>The processing of textures other than color texture type has been improved.&lt;/p>
&lt;ul>
&lt;li>NormalMap&amp;rsquo;s import/export correction: since this fix is also applied to MToon shader, we put the details in the next section&lt;/li>
&lt;li>Metallic, Roughness, OcclusionMap conversion:
&lt;ul>
&lt;li>RGBA channel recombination&lt;/li>
&lt;li>The relative relation between Roughness value and Smoothness value&lt;/li>
&lt;li>Support sRGB and Linear&lt;/li>
&lt;li>Convert Texture by Importer, reverse conversion on Texture by Exporter&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="correction-normalmaps-importexport">Correction: NormalMap&amp;rsquo;s Import/Export&lt;/h2>
&lt;p>Target for the textures of &lt;code>Standard&lt;/code> and &lt;code>MToon&lt;/code>.
Normal map can be identified by the keyword &lt;code>_BumpMap&lt;/code> in the material property.&lt;/p>
&lt;ul>
&lt;li>EditorImport: &lt;code>TextureImporterType.NormalMap&lt;/code>&lt;/li>
&lt;li>RuntimeImport: pack normal texture&lt;/li>
&lt;li>Export: unpack normal texture&lt;/li>
&lt;li>Support sRGB and Linear&lt;/li>
&lt;li>Support Tangent&lt;/li>
&lt;/ul>
&lt;h2 id="troubleshooting">Troubleshooting&lt;/h2>
&lt;ul>
&lt;li>The issue of causing glossy reflections:
&lt;ul>
&lt;li>It occurs when the shader type is &lt;code>Standard&lt;/code> (Unity standard) and the values of &lt;code>metallic&lt;/code> and &lt;code>smooth&lt;/code> are high. If you set the material&amp;rsquo;s shader to &lt;code>Unlit/UniUnlit&lt;/code>, the texture can be displayed as it supposes to be.&lt;/li>
&lt;li>When an unknown shader is selected (not supported by &lt;code>VRM&lt;/code>), the shader is defaulted to Standard shader and it may result in glossy reflections. If you set the material&amp;rsquo;s shader to &lt;code>Unlit/UniUnlit&lt;/code>, the texture can be displayed as it supposes to be.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Export Import</title><link>https://vrm.dev/en/docs/univrm/shaders/univrm_export_import/</link><pubDate>Mon, 03 Aug 2020 10:39:04 +0900</pubDate><guid>https://vrm.dev/en/docs/univrm/shaders/univrm_export_import/</guid><description>
&lt;h2 id="export">Export&lt;/h2>
&lt;h3 id="gltf-layer">GLTF Layer&lt;/h3>
&lt;p>The information is recorded in gltf&amp;rsquo;s &lt;code>/materials[]&lt;/code>.&lt;/p>
&lt;p>Only support the following two types:&lt;/p>
&lt;ul>
&lt;li>PBR (default)&lt;/li>
&lt;li>Unlit (KHR_materials_unlit extension)&lt;/li>
&lt;/ul>
&lt;h4 id="details">Details&lt;/h4>
&lt;p>If the material is one of the shaders in the following list, add &lt;code>KHR_materials_unlit&lt;/code> extension.&lt;/p>
&lt;ul>
&lt;li>Unlit/Color (Unity default)&lt;/li>
&lt;li>Unlit/Texture (Unity default)&lt;/li>
&lt;li>Unlit/Transparent (Unity default)&lt;/li>
&lt;li>Unlit/Transparent Cutout (Unity default)&lt;/li>
&lt;li>UniGLTF/UniUnlit (UniVRM)&lt;/li>
&lt;li>VRM/UnlitTexture (UniVRM)&lt;/li>
&lt;li>VRM/UnlitTransparent (UniVRM)&lt;/li>
&lt;li>VRM/UnlitCutout (UniVRM)&lt;/li>
&lt;/ul>
&lt;h3 id="vrm-layer">VRM Layer&lt;/h3>
&lt;p>The information is recorded in gltf&amp;rsquo;s &lt;code>/extensions/VRM/materialProperties[]&lt;/code>.&lt;/p>
&lt;p>Available shaders in VRM Layer:&lt;/p>
&lt;ul>
&lt;li>VRM/UnlitTransparentZWrite&lt;/li>
&lt;li>VRM/MToon&lt;/li>
&lt;/ul>
&lt;p>Other shaders will be set as &lt;code>VRM_USE_GLTFSHADER&lt;/code> in &lt;code>shaderName&lt;/code>.&lt;/p>
&lt;h2 id="import">Import&lt;/h2>
&lt;h3 id="gltf-layer-1">GLTF Layer&lt;/h3>
&lt;p>Create Unity material from GLTF&amp;rsquo;s &lt;code>/materials[]&lt;/code>.
If &lt;code>KHR_materials_unlit&lt;/code> extension is found, the material &lt;code>UniGLTF/UniUnlit&lt;/code> is created.&lt;/p>
&lt;p>&lt;a href="https://vrm.dev/en/docs/univrm/shaders/univrm_vrmshaders/#uniunlit">UniUnlit&lt;/a>&lt;/p>
&lt;h3 id="vrm-layer-1">VRM Layer&lt;/h3>
&lt;p>Create Unity material from GLTF&amp;rsquo;s &lt;code>/extensions/VRM/materialProperties[]&lt;/code>.
If &lt;code>shaderName&lt;/code> is &lt;code>VRM_USE_GLTFSHADER&lt;/code>, use the information recorded in &lt;code>/materials[]&lt;/code> and process as &lt;code>GLTF&lt;/code>'s &lt;code>PBR&lt;/code> or &lt;code>Unlit&lt;/code>.&lt;/p>
&lt;h2 id="shader-change">Shader Change&lt;/h2>
&lt;p>The shader may be changed after export/import:&lt;/p>
&lt;ul>
&lt;li>if unsupported shaders are imported, they will be changed to &lt;code>Standard&lt;/code>. GLTF&amp;rsquo;s &lt;code>PBR&lt;/code> will be set to &lt;code>Standard&lt;/code> due to the majority of the properties are compatible&lt;/li>
&lt;li>if shaders are unlit type, they will be &lt;a href="https://vrm.dev/en/docs/univrm/shaders/univrm_unlit/">UniGLTF/UniUnlit&lt;/a> (this is the normal conversion).&lt;/li>
&lt;/ul>
&lt;h2 id="vrm_use_gltfshader">VRM_USE_GLTFSHADER&lt;/h2>
&lt;p>The information is recorded in:&lt;/p>
&lt;p>&lt;code>/extensions/VRM/materialProperties[]&lt;/code>&lt;/p>
&lt;p>Supported Shaders:&lt;/p>
&lt;ul>
&lt;li>VRM/MToon&lt;/li>
&lt;/ul>
&lt;p>Currently VRM supported shaders are &lt;code>PBR(Standard)&lt;/code>, &lt;code>Unlit&lt;/code>, &lt;code>MToon&lt;/code>.&lt;/p></description></item><item><title>Docs: VRMShaders UPM Package</title><link>https://vrm.dev/en/docs/univrm/shaders/univrm_vrmshaders/</link><pubDate>Mon, 03 Aug 2020 10:39:04 +0900</pubDate><guid>https://vrm.dev/en/docs/univrm/shaders/univrm_vrmshaders/</guid><description>
&lt;p>Starting from &lt;code>UniVRM-0.56&lt;/code>, the folder structure in UniVRM has been changed.
Material-related parts in &lt;code>UniVRM&lt;/code> has been moved to &lt;code>Assets/VRMShaders&lt;/code>.&lt;/p>
&lt;h2 id="upm-package">UPM Package&lt;/h2>
&lt;p>VRMShaders can be used as a package to be imported into a Unity Project via Unity Package Manger.
Besides that, VRMShaders can be used independently without &lt;code>UniVRM&lt;/code> (&lt;code>UniVRM&lt;/code> uses &lt;code>VRMShaders&lt;/code>).
VRMShaders includes &lt;code>UniUnlit&lt;/code> and &lt;code>MToon&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">&lt;span style="color:#a00;background-color:#faa">//&lt;/span> &lt;span style="color:#a00;background-color:#faa">manifest.json&lt;/span>
{
&lt;span style="color:#309;font-weight:bold">&amp;#34;dependencies&amp;#34;&lt;/span>: {
&lt;span style="color:#309;font-weight:bold">&amp;#34;com.vrmc.vrmshaders&amp;#34;&lt;/span>: &lt;span style="color:#c30">&amp;#34;https://github.com/vrm-c/UniVRM.git?path=/Assets/VRMShaders#v0.57.0&amp;#34;&lt;/span>,
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this example, the version of UniVRM being imported is v0.57.0.
The imported version can be changed to different version (e.g. v0.56.0).
&lt;code>VRMShaders&lt;/code> version number is the same as UniVRM.&lt;/p>
&lt;h3 id="uniunlit">UniUnlit&lt;/h3>
&lt;p>&lt;a href="https://vrm.dev/en/docs/univrm/shaders/univrm_unlit/">unlit&lt;/a>&lt;/p>
&lt;h3 id="mtoon">MToon&lt;/h3>
&lt;p>In VRMShaders, MToon shader is managed by &lt;code>git submodule&lt;/code>:&lt;/p>
&lt;p>&lt;a href="https://github.com/vrm-c/UniVRM/tree/master/Assets/VRMShaders">https://github.com/vrm-c/UniVRM/tree/master/Assets/VRMShaders&lt;/a>&lt;/p>
&lt;p>For the latest update about MToon, please refer to:&lt;/p>
&lt;p>&lt;a href="https://github.com/Santarh/MToon">https://github.com/Santarh/MToon&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://vrm.dev/en/docs/univrm/shaders/shader_mtoon/">Introduction to MToon&lt;/a>&lt;/p></description></item><item><title>Docs: Texture Import</title><link>https://vrm.dev/en/docs/univrm/shaders/texture_import/</link><pubDate>Wed, 17 Mar 2021 11:10:12 +0900</pubDate><guid>https://vrm.dev/en/docs/univrm/shaders/texture_import/</guid><description>
&lt;h2 id="texture-conversion-for-unitys-standard-shader">Texture Conversion for Unity&amp;rsquo;s Standard Shader&lt;/h2>
&lt;p>The table below is the RGB channel conversion between glTF&amp;rsquo;s material (PBR) and Unity Standard Shader:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">Texture Type&lt;/th>
&lt;th align="left">glTF&lt;/th>
&lt;th align="left">Unity&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">Occlusion&lt;/td>
&lt;td align="left">materials[*].occlusionTexture&amp;rsquo;s R channel&lt;/td>
&lt;td align="left">Standard._MetallicGlossMap.G channel&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Roughness&lt;/td>
&lt;td align="left">materials[*].pbrMetallicRoughness.metallicRoughnessTexture&amp;rsquo;s G channel&lt;/td>
&lt;td align="left">Standard._MetallicGlossMap.A channel (smoothness = 1 - roughness) &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Metallic&lt;/td>
&lt;td align="left">materials[*].pbrMetallicRoughness.metallicRoughnessTexture&amp;rsquo;s B channel&lt;/td>
&lt;td align="left">Standard._OcclusionMap.R channel&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>UniGLTF will perform the RGB channel conversion when textures are imported into Unity.&lt;/p>
&lt;h3 id="texture-import-behaviors">Texture Import Behaviors&lt;/h3>
&lt;p>Starting with &lt;code>v0.69.0&lt;/code>, Metallic, Smooth and Occlusion textures are integrated into one:&lt;/p>
&lt;ul>
&lt;li>import: glTF&amp;rsquo;s metallicRoughnessTexture and occlusionTexture are integrated into one (as seen in the table above)&lt;/li>
&lt;li>export: Standard&amp;rsquo;s _MetallicGlossMap and _OcclusionMap are integrated into one (as seen in the table above)&lt;/li>
&lt;/ul>
&lt;p>Before &lt;code>v0.69.0&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>import: convert and import textures to be used for _MetallicGlossMap and _OcclusionMap&lt;/li>
&lt;li>export: convert and export Standard&amp;rsquo;s _MetallicGlossMap and _OcclusionMap&lt;/li>
&lt;/ul>
&lt;h3 id="gltf">glTF&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialocclusiontexture">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialocclusiontexture&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>The occlusion values are sampled from the R channel&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#pbrmetallicroughnessmetallicroughnesstexture">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#pbrmetallicroughnessmetallicroughnesstexture&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>The metalness values are sampled from the B channel. The roughness values are sampled from the G channel&lt;/p>
&lt;/blockquote>
&lt;h3 id="unity">Unity&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://docs.unity3d.com/Manual/StandardShaderMaterialParameterMetallic.html">https://docs.unity3d.com/Manual/StandardShaderMaterialParameterMetallic.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>the Metallic levels for the material are controlled by the values in the Red channel of the texture
the Smoothness levels for the material are controlled by the Alpha channel of the texture&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://docs.unity3d.com/Manual/StandardShaderMaterialParameterOcclusionMap.html">https://docs.unity3d.com/Manual/StandardShaderMaterialParameterOcclusionMap.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="metallicroughness-texture">&lt;code>MetallicRoughness&lt;/code> Texture&lt;/h3>
&lt;ul>
&lt;li>glTF&amp;rsquo;s Metallic =&amp;gt; Blue&lt;/li>
&lt;li>glTF&amp;rsquo;s Roughness =&amp;gt; Green&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/schema/material.pbrMetallicRoughness.schema.json#L45">https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/schema/material.pbrMetallicRoughness.schema.json#L45&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>The metalness values are sampled from the B channel. The roughness values are sampled from the G channel.&lt;/p>
&lt;/blockquote>
&lt;p>In Unity,&lt;/p>
&lt;ul>
&lt;li>Unity&amp;rsquo;s Standard(Metallic Alpha) Metallic =&amp;gt; Alpha&lt;/li>
&lt;li>Unity&amp;rsquo;s Standard(Metallic Alpha) Smooth =&amp;gt; Red&lt;/li>
&lt;/ul>
&lt;p>which are assigned to different channels as compared to gltf spec.
For &lt;code>UniGLTF&lt;/code>, it will load &lt;code>png/jpg&lt;/code> images first, and then create converted textures to be used in Unity&amp;rsquo;s Standard Shader.&lt;/p>
&lt;h2 id="unitys-linear-texture-behaviors">Unity&amp;rsquo;s Linear Texture Behaviors&lt;/h2>
&lt;h3 id="runtime">Runtime&lt;/h3>
&lt;p>Initialize a new texture as linear:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#078;font-weight:bold">var&lt;/span> texture = &lt;span style="color:#069;font-weight:bold">new&lt;/span> Texture2D(width, height, format, mipChain, linear = &lt;span style="color:#069;font-weight:bold">true&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="asset">Asset&lt;/h3>
&lt;p>If textures are loaded from AssetFolder&amp;rsquo;s png/jpg:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#078;font-weight:bold">var&lt;/span> textureImporter = AssetImporter.GetAtPath(assetPath) &lt;span style="color:#069;font-weight:bold">as&lt;/span> TextureImporter;
textureImporter.sRGBTexture = &lt;span style="color:#069;font-weight:bold">false&lt;/span>; &lt;span style="color:#09f;font-style:italic">// Linear
&lt;/span>&lt;span style="color:#09f;font-style:italic">&lt;/span>textureImporter.SaveAndReimport();
&lt;span style="color:#09f;font-style:italic">// loaded as linear texture
&lt;/span>&lt;span style="color:#09f;font-style:italic">&lt;/span>&lt;span style="color:#078;font-weight:bold">var&lt;/span> texture =AssetDatabase.LoadAssetAtPath&amp;lt;Texture2D&amp;gt;(assetPath);
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="unitys-normalmap-behaviors">Unity&amp;rsquo;s NormalMap Behaviors&lt;/h2>
&lt;blockquote>
&lt;p>Same as MToon&amp;rsquo;s NormalMap&lt;/p>
&lt;/blockquote>
&lt;h3 id="runtime-1">Runtime&lt;/h3>
&lt;p>Initialize a new texture for NormalMap:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#078;font-weight:bold">var&lt;/span> texture = &lt;span style="color:#069;font-weight:bold">new&lt;/span> Texture2D(width, height, format, mipChain, linear = &lt;span style="color:#069;font-weight:bold">true&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Since the normal texture needs to be converted to &lt;code>DXT5nm&lt;/code> format, we do the conversion described below:&lt;/p>
&lt;pre>&lt;code class="language-hlsl" data-lang="hlsl">half4 normal;
normal.x = 1.0;
normal.y = col.y;
normal.z = 1.0;
normal.w = col.x;
&lt;/code>&lt;/pre>&lt;h3 id="asset-1">Asset&lt;/h3>
&lt;p>If textures are loaded from AssetFolder&amp;rsquo;s png/jpg:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#078;font-weight:bold">var&lt;/span> textureImporter = AssetImporter.GetAtPath(assetPath) &lt;span style="color:#069;font-weight:bold">as&lt;/span> TextureImporter;
textureImporter.textureType = TextureImporterType.NormalMap; &lt;span style="color:#09f;font-style:italic">// normalMap
&lt;/span>&lt;span style="color:#09f;font-style:italic">&lt;/span>textureImporter.SaveAndReimport();
&lt;span style="color:#09f;font-style:italic">// loaded as DXT5nm format
&lt;/span>&lt;span style="color:#09f;font-style:italic">&lt;/span>&lt;span style="color:#078;font-weight:bold">var&lt;/span> texture =AssetDatabase.LoadAssetAtPath&amp;lt;Texture2D&amp;gt;(assetPath);
&lt;/code>&lt;/pre>&lt;/div>&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Fixed roughness conversion in &lt;code>v0.69.0&lt;/code> &lt;a href="https://github.com/vrm-c/UniVRM/issues/388">#388&lt;/a> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item></channel></rss>